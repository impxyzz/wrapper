import { EventsSDK, Menu, EntityManager, Player, ArrayExtensions, Hero, LocalPlayer, TickSleeper, npc_dota_hero_meepo } from "wrapper/Imports"
let root = Menu.AddEntry(["Utility", "Custom game exploits", "Custom Hero Chaos"])
let bet_hate = root.AddImageSelector("Players to hate (bet)", [])
let actor_hate = root.AddImageSelector("Players to hate (actor)", [])
let ability_hate = root.AddImageSelector("Players to hate (ability selection)", [])
let ability_swap_hate = root.AddImageSelector("Players to hate (ability swap)", [])
let make_actor_hate = root.AddImageSelector("Make player actor", [])
let sleeper = new TickSleeper()

EventsSDK.on("GameStarted", () => {
	bet_hate.enabled_values.clear() // reset state every game since it's based on playerIDs
	actor_hate.enabled_values.clear() // reset state every game since it's based on playerIDs
	ability_hate.enabled_values.clear() // reset state every game since it's based on playerIDs
	ability_swap_hate.enabled_values.clear() // reset state every game since it's based on playerIDs
	make_actor_hate.enabled_values.clear() // reset state every game since it's based on playerIDs
})

EventsSDK.on("GameEnded", () => {
	bet_hate.values = []
	bet_hate.Update()
	actor_hate.values = []
	actor_hate.Update()
	ability_hate.values = []
	ability_hate.Update()
	ability_swap_hate.values = []
	ability_swap_hate.Update()
	make_actor_hate.values = []
	make_actor_hate.Update()
	sleeper.ResetTimer()
})

let pair = { "1": 1, "2": 2 }
EventsSDK.on("CustomGameEvent", (name, obj) => {
	if (name === "ShowPvpBet")
		pair = obj.pair
})

function CreateSecretKeyPart() {
	return Math.min(Math.max(Math.floor(Math.random() * 10000), 1), 9999)
}

function CreateSecretKey() {
	return `${CreateSecretKeyPart()}-${CreateSecretKeyPart()}-${CreateSecretKeyPart()}-${CreateSecretKeyPart()}`
}

function LookupPlayerByHeroName(hero_name: string): Nullable<Player> {
	let hero = EntityManager.GetEntitiesByClass(Hero).find(hero => hero.Name === hero_name && hero.Owner instanceof Player && hero.Owner.Hero === hero)
	if (hero === undefined)
		return undefined
	return EntityManager.GetEntitiesByClass(Player).find(player => player.PlayerID === hero.PlayerID)
}

EventsSDK.on("Tick", () => {
	make_actor_hate.values = ability_swap_hate.values = ability_hate.values = actor_hate.values = bet_hate.values = ArrayExtensions.orderBy(
		EntityManager.GetEntitiesByClass(Hero).filter(h => !h.IsIllusion && !h.IsTempestDouble && !(h instanceof npc_dota_hero_meepo && h.IsClone)),
		p => p.PlayerID
	).map(a => a.Name)
	bet_hate.Update()
	actor_hate.Update()
	ability_hate.Update()
	ability_swap_hate.Update()
	make_actor_hate.Update()
	if (bet_hate.values.length === 0)
		return
	// loop-optimizer: KEEP
	bet_hate.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		let player = LookupPlayerByHeroName(hero_name)
		if (player === undefined)
			return
		GameEvents.FireEventToClient("ShowPvpBet", player.Index, {
			pair,
			bet_ui_secret: CreateSecretKey(),
		})
	})
	// loop-optimizer: KEEP
	actor_hate.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		let player = LookupPlayerByHeroName(hero_name)
		if (player === undefined)
			return
		GameEvents.FireEventToClient("ShowActorPanel", player.Index, {
			target_player_id: player.PlayerID,
			time: 1,
		})
	})
	// loop-optimizer: KEEP
	ability_hate.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		let player = LookupPlayerByHeroName(hero_name)
		if (player === undefined)
			return
		GameEvents.FireEventToClient("ShowRandomAbilitySelection", player.Index, {
			data_list: {},
			ability_number: player.Hero!.Spells.slice(0, 6).filter(a => a !== undefined).length + 1,
			ui_secret: CreateSecretKey(),
		})
	})
	// loop-optimizer: KEEP
	ability_swap_hate.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		let player = LookupPlayerByHeroName(hero_name)
		if (player === undefined)
			return
		GameEvents.FireEventToClient("RefreshAbilityOrder", player.Index, {
			swap_ui_secret: CreateSecretKey(),
		})
	})
	// loop-optimizer: KEEP
	make_actor_hate.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		const player = LookupPlayerByHeroName(hero_name)
		if (player === undefined)
			return
		EntityManager.GetEntitiesByClass(Player).forEach(p => GameEvents.FireEventToServer("ConfirmActor", {
			player_id: p.PlayerID,
			target_player_id: player.PlayerID,
		}))
	})
})
