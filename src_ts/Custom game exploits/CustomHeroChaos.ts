import { EventsSDK, Menu, EntityManager, Player, ArrayExtensions, Hero, Utils, Parse, LocalPlayer, dotaunitorder_t, ExecuteOrder, Vector3, Item, TickSleeper } from "wrapper/Imports"
let root = Menu.AddEntry(["Utility", "Custom game exploits", "Custom Hero Chaos"])
let ability_giver = root.AddNode("Ability Giver")
let abilities_to_roll = ability_giver.AddImageSelector("Select abilities to roll", [])
let show_heroes = ability_giver.AddImageSelector("Heroes to show", [])
let ability_replace = ability_giver.AddImageSelector("Ability to replace", [])
let roll_ability = ability_giver.AddButton("Roll ability")
let players = root.AddImageSelector("Players to spend gold", [])
let hate_players = root.AddImageSelector("Players to hate", [])
let book_players = root.AddImageSelector("Players to give books", [])
let invisible_exploits = root.AddNode("Invisible exploits")
let dupe_gold = invisible_exploits.AddToggle("Dupe gold")
let sell_own_illus_items = invisible_exploits.AddToggle("Sell own illusions items")
let hero_ability_list: { [key: string]: string[] } = {}
let sleeper = new TickSleeper()

/*let abilityExclusion = new Map([
	["lone_druid_true_form", "lone_druid_spirit_bear"],
	["lone_druid_spirit_bear", "lone_druid_true_form"],
	["dazzle_bad_juju", "puck_phase_shift"],
	["puck_phase_shift", "dazzle_bad_juju"],
	["dazzle_bad_juju", "dark_willow_shadow_realm"],
	["dark_willow_shadow_realm", "dazzle_bad_juju"],
	["drow_ranger_marksmanship", "faceless_void_time_lock"],
	["faceless_void_time_lock", "drow_ranger_marksmanship"],
])
let heroExclusion = new Map([
	["npc_dota_hero_drow_ranger", ["dazzle_bad_juju", "puck_phase_shift", "dark_willow_shadow_realm"]],
	["npc_dota_hero_nevermore", ["dazzle_bad_juju", "puck_phase_shift", "dark_willow_shadow_realm"]],
])
let abilityPersonal = new Map([
	["zuus_static_field", "npc_dota_hero_zuus"],
	["legion_commander_moment_of_courage", "npc_dota_hero_legion_commander"],
])*/
let unremovableAbilities = ["shredder_chakram", "monkey_king_wukongs_command", "elder_titan_ancestral_spirit"]

EventsSDK.on("GameStarted", () => {
	players.enabled_values.clear() // reset state every game since it's based on playerIDs
	hate_players.enabled_values.clear()
	book_players.enabled_values.clear()
	let kv = Utils.parseKVFile("scripts/npc/npc_abilities_list.txt")
	if (kv.size === 0)
		return
	show_heroes.values = []
	show_heroes.enabled_values.clear()
	hero_ability_list = {}
	abilities_to_roll.values = []
	abilities_to_roll.enabled_values.clear()
	abilities_to_roll.Update()
	sleeper.ResetTimer()
	let CustomAbilities = kv.get("CustomAbilities") as Parse.RecursiveMap
	// loop-optimizer: KEEP
	CustomAbilities.forEach((val, key) => {
		if (!(val instanceof Map))
			return
		let ar: string[] = []
		// loop-optimizer: KEEP
		val.forEach((val_, key_) => {
			if (typeof val_ === "string")
				ar.push(val_)
		})
		hero_ability_list[key] = ar
		show_heroes.values.push(`npc_dota_hero_${key}`)
	})
	show_heroes.values = show_heroes.values.sort()
	show_heroes.Update()
})
let current_replacing = "",
	waiting_ability_selection = false
EventsSDK.on("GameEnded", () => {
	players.values = []
	players.Update()
	hate_players.values = []
	hate_players.Update()
	book_players.values = []
	book_players.Update()
	show_heroes.values = []
	show_heroes.enabled_values.clear()
	show_heroes.Update()
	abilities_to_roll.values = []
	abilities_to_roll.enabled_values.clear()
	abilities_to_roll.Update()
	current_replacing = ""
	waiting_ability_selection = false
	sleeper.ResetTimer()
})
show_heroes.OnValue(selector => {
	abilities_to_roll.values = []
	// loop-optimizer: KEEP
	selector.enabled_values.forEach((val, key) => {
		if (!val)
			return
		let ar = hero_ability_list[key.substring(14)]
		if (ar === undefined)
			return
		abilities_to_roll.values = ar.concat(abilities_to_roll.values)
	})
	abilities_to_roll.Update()
})

function GiveBook(pid = LocalPlayer!.PlayerID) {
	GameEvents.FireEventToServer("RelearnBookAbilitySelected", {
		player_id: pid,
	})
}

roll_ability.OnValue(() => {
	if (current_replacing !== "")
		return
	// loop-optimizer: KEEP
	ability_replace.enabled_values.forEach((val, key) => {
		if (val && current_replacing === "" && ability_replace.values.includes(key))
			current_replacing = key
	})
	ability_replace.enabled_values.clear()
	ability_replace.Update()
	if (current_replacing !== "")
		GiveBook()
})

let pair = { "1": 1, "2": 2 }
EventsSDK.on("CustomGameEvent", (name, obj) => {
	if (name === "ShowPvpBet")
		pair = obj.pair
	else if (name === "ShowRelearnBookAbilitySelection" && current_replacing !== "") {
		GameEvents.FireEventToServer("RelearnBookAbilitySelected", {
			player_id: LocalPlayer!.PlayerID,
			ability_name: current_replacing,
		})
		waiting_ability_selection = true
	} else if (name === "ShowRandomAbilitySelection" && waiting_ability_selection) {
		let abils = Object.values(obj.data_list).map(o => (o as any).ability_name) as string[]
		let abil = abils.find(abil => abilities_to_roll.values.includes(abil) && abilities_to_roll.enabled_values.get(abil) === true)
		GameEvents.FireEventToServer("AbilitySelected", {
			player_id: LocalPlayer!.PlayerID,
			ability_name: abil ?? abils[0],
			spell_book_selected: 0,
		})
		if (abil === undefined) {
			current_replacing = abils[0]
			GiveBook()
		} else
			current_replacing = ""
		waiting_ability_selection = false
	}
})

EventsSDK.on("Tick", () => {
	const hero = LocalPlayer!.Hero
	if (hero !== undefined) {
		ability_replace.values = hero.Spells.map(spell => spell?.Name).filter(name => name !== undefined && !unremovableAbilities.includes(name)) as string[]
		ability_replace.Update()
		/*hero.Spells.forEach(spell => {
			if (spell === undefined)
				return
			let forbid = abilityExclusion.get(spell.Name)
			if (forbid !== undefined)
				ArrayExtensions.arrayRemove(ability_roll.values, forbid)
		})
		heroExclusion.get(hero.Name)?.forEach(forbid => ArrayExtensions.arrayRemove(ability_roll.values, forbid))
		// loop-optimizer: KEEP
		abilityPersonal.forEach((hero_name, spell) => {
			if (hero_name !== hero.Name)
				ArrayExtensions.arrayRemove(ability_roll.values, spell)
		})
		ability_roll.Update()*/

		if (!sleeper.Sleeping) {
			let hate_enabled = false,
				book_enabled = false
			// loop-optimizer: KEEP
			hate_players.enabled_values.forEach(val => hate_enabled = hate_enabled || val)
			// loop-optimizer: KEEP
			book_players.enabled_values.forEach(val => book_enabled = book_enabled || val)
			let seller = EntityManager.GetEntitiesByClass(Player).find(a => a.Hero?.IsAlive)?.Hero
			if (current_replacing !== "" && !waiting_ability_selection && hero.IsAlive) {
				let book = hero.GetItemByName("item_relearn_book_lua")
				if (book !== undefined) {
					hero.CastNoTarget(book, false)
					sleeper.Sleep(70)
				}
			} else if (sell_own_illus_items.value || hate_enabled) {
				let item = EntityManager.GetEntitiesByClass(Item).find(item => {
					if (!item.Owner?.Inventory?.TotalItems?.includes(item))
						return false
					if (hate_enabled)
						return hate_players.enabled_values.get(item.Owner?.Name) === true && item.Name !== "item_relearn_book_lua"
					if (sell_own_illus_items.value)
						return item.RootOwner === LocalPlayer && item.Owner?.IsIllusion
					return true
				})
				if (item !== undefined) {
					new ExecuteOrder(
						dotaunitorder_t.DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN,
						undefined,
						new Vector3(),
						item,
						PlayerOrderIssuer_t.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY,
						seller!,
						false,
						false
					).Execute()
					sleeper.Sleep(70)
				}
			} else if (book_enabled) {
				EntityManager.GetEntitiesByClass(Player).forEach(pl => {
					if (book_players.enabled_values.get(pl.Hero?.Name!) === true)
						GiveBook(pl.PlayerID)
				})
			} else {
				let book = hero.Inventory.TotalItems.find(a => a?.Name === "item_relearn_book_lua")
				if (book !== undefined) {
					new ExecuteOrder(
						dotaunitorder_t.DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN,
						undefined,
						new Vector3(),
						book,
						PlayerOrderIssuer_t.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY,
						seller!,
						false,
						false
					).Execute()
					sleeper.Sleep(70)
				} else if (dupe_gold.value)
					GiveBook()
			}
		}
	}
	book_players.values = hate_players.values = players.values = ArrayExtensions.orderBy(
		EntityManager.GetEntitiesByClass(Player).filter(p => p.Hero !== undefined),
		p => p.PlayerID
	).map(a => a.Hero!.Name)
	players.Update()
	hate_players.Update()
	book_players.Update()
	if (players.values.length === 0)
		return
	// loop-optimizer: KEEP
	players.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		let hero = EntityManager.GetEntitiesByClass(Hero).find(hero => hero.Name === hero_name && hero.Owner instanceof Player && hero.Owner.Hero === hero)
		if (hero === undefined)
			return
		GameEvents.FireEventToServer("ConfirmBet", {
			player_id: (hero.Owner as Player).PlayerID,
			value: 100000,
			wish_player_id: pair[(Math.random() > 0.5) ? "1" : "2"],
		})
	})
})
