var rotation_speed = {
		npc_dota_hero_base: 0.5,
		npc_dota_hero_antimage: 0.5,
		npc_dota_hero_axe: 0.6,
		npc_dota_hero_bane: 0.6,
		npc_dota_hero_bloodseeker: 0.5,
		npc_dota_hero_crystal_maiden: 0.5,
		npc_dota_hero_drow_ranger: 0.7,
		npc_dota_hero_earthshaker: 0.9,
		npc_dota_hero_juggernaut: 0.6,
		npc_dota_hero_mirana: 0.5,
		npc_dota_hero_nevermore: 1,
		npc_dota_hero_morphling: 0.6,
		npc_dota_hero_phantom_lancer: 0.6,
		npc_dota_hero_puck: 0.5,
		npc_dota_hero_pudge: 0.7,
		npc_dota_hero_razor: 0.5,
		npc_dota_hero_sand_king: 0.5,
		npc_dota_hero_storm_spirit: 0.8,
		npc_dota_hero_sven: 0.6,
		npc_dota_hero_tiny: 0.5,
		npc_dota_hero_vengefulspirit: 0.6,
		npc_dota_hero_windrunner: 0.8,
		npc_dota_hero_zuus: 0.6,
		npc_dota_hero_kunkka: 0.6,
		npc_dota_hero_lina: 0.5,
		npc_dota_hero_lich: 0.5,
		npc_dota_hero_lion: 0.5,
		npc_dota_hero_shadow_shaman: 0.5,
		npc_dota_hero_slardar: 0.5,
		npc_dota_hero_tidehunter: 0.5,
		npc_dota_hero_witch_doctor: 0.5,
		npc_dota_hero_riki: 0.6,
		npc_dota_hero_enigma: 0.5,
		npc_dota_hero_tinker: 0.6,
		npc_dota_hero_sniper: 0.7,
		npc_dota_hero_necrolyte: 0.5,
		npc_dota_hero_warlock: 0.5,
		npc_dota_hero_beastmaster: 0.5,
		npc_dota_hero_queenofpain: 0.5,
		npc_dota_hero_venomancer: 0.5,
		npc_dota_hero_faceless_void: 1,
		npc_dota_hero_skeleton_king: 0.5,
		npc_dota_hero_death_prophet: 0.5,
		npc_dota_hero_phantom_assassin: 0.6,
		npc_dota_hero_pugna: 0.5,
		npc_dota_hero_templar_assassin: 0.7,
		npc_dota_hero_viper: 0.5,
		npc_dota_hero_luna: 0.6,
		npc_dota_hero_dragon_knight: 0.6,
		npc_dota_hero_dazzle: 0.6,
		npc_dota_hero_rattletrap: 0.6,
		npc_dota_hero_leshrac: 0.5,
		npc_dota_hero_furion: 0.6,
		npc_dota_hero_life_stealer: 1,
		npc_dota_hero_dark_seer: 0.6,
		npc_dota_hero_clinkz: 0.5,
		npc_dota_hero_omniknight: 0.6,
		npc_dota_hero_enchantress: 0.5,
		npc_dota_hero_huskar: 0.5,
		npc_dota_hero_night_stalker: 0.5,
		npc_dota_hero_broodmother: 0.5,
		npc_dota_hero_bounty_hunter: 0.6,
		npc_dota_hero_weaver: 0.5,
		npc_dota_hero_jakiro: 0.5,
		npc_dota_hero_batrider: 1,
		npc_dota_hero_chen: 0.6,
		npc_dota_hero_spectre: 0.5,
		npc_dota_hero_doom_bringer: 0.5,
		npc_dota_hero_ancient_apparition: 0.6,
		npc_dota_hero_ursa: 0.5,
		npc_dota_hero_spirit_breaker: 0.5,
		npc_dota_hero_gyrocopter: 0.6,
		npc_dota_hero_alchemist: 0.6,
		npc_dota_hero_invoker: 0.5,
		npc_dota_hero_silencer: 0.6,
		npc_dota_hero_obsidian_destroyer: 0.5,
		npc_dota_hero_lycan: 0.5,
		npc_dota_hero_brewmaster: 0.6,
		npc_dota_hero_shadow_demon: 0.6,
		npc_dota_hero_lone_druid: 0.5,
		npc_dota_hero_chaos_knight: 0.5,
		npc_dota_hero_meepo: 0.65,
		npc_dota_hero_treant: 0.5,
		npc_dota_hero_ogre_magi: 0.6,
		npc_dota_hero_undying: 0.6,
		npc_dota_hero_rubick: 0.7,
		npc_dota_hero_disruptor: 0.5,
		npc_dota_hero_nyx_assassin: 0.5,
		npc_dota_hero_naga_siren: 0.5,
		npc_dota_hero_keeper_of_the_light: 0.5,
		npc_dota_hero_wisp: 0.7,
		npc_dota_hero_visage: 0.5,
		npc_dota_hero_slark: 0.6,
		npc_dota_hero_medusa: 0.5,
		npc_dota_hero_troll_warlord: 0.5,
		npc_dota_hero_centaur: 0.5,
		npc_dota_hero_magnataur: 0.8,
		npc_dota_hero_shredder: 0.6,
		npc_dota_hero_bristleback: 1,
		npc_dota_hero_tusk: 0.7,
		npc_dota_hero_skywrath_mage: 0.5,
		npc_dota_hero_abaddon: 0.5,
		npc_dota_hero_elder_titan: 0.5,
		npc_dota_hero_legion_commander: 0.5,
		npc_dota_hero_ember_spirit: 0.5,
		npc_dota_hero_earth_spirit: 0.6,
		npc_dota_hero_terrorblade: 0.5,
		npc_dota_hero_phoenix: 1,
		npc_dota_hero_oracle: 0.7,
		npc_dota_hero_techies: 0.5,
		npc_dota_hero_target_dummy: 0.5,
		npc_dota_hero_winter_wyvern: 0.5,
		npc_dota_hero_arc_warden: 0.6,
		npc_dota_hero_abyssal_underlord: 0.6,
		npc_dota_hero_monkey_king: 0.6,
		npc_dota_hero_pangolier: 1,
		npc_dota_hero_dark_willow: 0.7,
		npc_dota_hero_grimstroke: 0.6,
		npc_dota_hero_mars: 0.8,
	},
	projectile_speeds = {
		npc_dota_hero_bane: 900,
		npc_dota_hero_crystal_maiden: 900,
		npc_dota_hero_drow_ranger: 1250,
		npc_dota_hero_mirana: 900,
		npc_dota_hero_nevermore: 1200,
		npc_dota_hero_morphling: 1300,
		npc_dota_hero_puck: 900,
		npc_dota_hero_razor: 2000,
		npc_dota_hero_storm_spirit: 1100,
		npc_dota_hero_vengefulspirit: 1500,
		npc_dota_hero_windrunner: 1250,
		npc_dota_hero_zuus: 1100,
		npc_dota_hero_lina: 1000,
		npc_dota_hero_lich: 900,
		npc_dota_hero_lion: 900,
		npc_dota_hero_shadow_shaman: 900,
		npc_dota_hero_witch_doctor: 1200,
		npc_dota_hero_enigma: 900,
		npc_dota_hero_tinker: 900,
		npc_dota_hero_sniper: 3000,
		npc_dota_hero_necrolyte: 900,
		npc_dota_hero_warlock: 1200,
		npc_dota_hero_queenofpain: 1500,
		npc_dota_hero_venomancer: 900,
		npc_dota_hero_death_prophet: 1000,
		npc_dota_hero_pugna: 900,
		npc_dota_hero_templar_assassin: 900,
		npc_dota_hero_viper: 1200,
		npc_dota_hero_luna: 900,
		npc_dota_hero_dragon_knight: 900,
		npc_dota_hero_dazzle: 1200,
		npc_dota_hero_leshrac: 900,
		npc_dota_hero_furion: 1125,
		npc_dota_hero_clinkz: 900,
		npc_dota_hero_enchantress: 900,
		npc_dota_hero_huskar: 1400,
		npc_dota_hero_weaver: 900,
		npc_dota_hero_jakiro: 1100,
		npc_dota_hero_batrider: 900,
		npc_dota_hero_chen: 1100,
		npc_dota_hero_ancient_apparition: 1250,
		npc_dota_hero_gyrocopter: 3000,
		npc_dota_hero_invoker: 900,
		npc_dota_hero_silencer: 1000,
		npc_dota_hero_obsidian_destroyer: 900,
		npc_dota_hero_shadow_demon: 900,
		npc_dota_hero_lone_druid: 900,
		npc_dota_hero_rubick: 1125,
		npc_dota_hero_disruptor: 1200,
		npc_dota_hero_keeper_of_the_light: 900,
		npc_dota_hero_wisp: 1200,
		npc_dota_hero_visage: 900,
		npc_dota_hero_medusa: 1200,
		npc_dota_hero_troll_warlord: 1200,
		npc_dota_hero_skywrath_mage: 1000,
		npc_dota_hero_terrorblade: 900,
		npc_dota_hero_phoenix: 1100,
		npc_dota_hero_oracle: 900,
		npc_dota_hero_techies: 900,
		npc_dota_hero_target_dummy: 900,
		npc_dota_hero_winter_wyvern: 700,
		npc_dota_hero_arc_warden: 900,
		npc_dota_hero_dark_willow: 1200,
		npc_dota_hero_grimstroke: 900,
	},
	attacks: Array<[number, number, C_DOTA_BaseNPC]> = [],
	CursorWorldVec = new Vector3(),
	melee_end_time_delta = 0.06,
	masksBigInt = new Array(64)

for (let i = 64; i--;)
	masksBigInt[i] = 1n << BigInt(i)
export function SplitBigInt(num: bigint): number[] {
	return masksBigInt.map(mask => Number(num & mask)).filter(masked => masked !== 0)
}

export let IsAlive = (ent: C_BaseEntity) => ent.m_lifeState === LifeState_t.LIFE_ALIVE
export let IsEnemy = (ent: C_BaseEntity, enemy: C_BaseEntity) => ent.m_iTeamNum !== enemy.m_iTeamNum
export let IsVisible = (ent: C_BaseEntity) => ent.m_pEntity !== undefined && (ent.m_pEntity.m_flags & (1 << 7)) === 0

export let IsUnitStateFlagSet = (ent: C_DOTA_BaseNPC, flag: modifierstate) =>
	(((ent.m_nUnitState64 | ent.m_nUnitDebuffState) >> BigInt(flag)) & 1n) === 1n

export let HasAttackCapability = (ent: C_DOTA_BaseNPC, flag?: DOTAUnitAttackCapability_t) => {
	let attackCap = ent.m_iAttackCapabilities

	if (flag !== undefined)
		return (attackCap & flag) === flag

	return (attackCap & (
		DOTAUnitAttackCapability_t.DOTA_UNIT_CAP_MELEE_ATTACK |
		DOTAUnitAttackCapability_t.DOTA_UNIT_CAP_RANGED_ATTACK)
	) === flag
}

export let IsVisibleForEnemies = (ent: C_DOTA_BaseNPC) => {
	const valid_teams = ~(1
		| (1 << DOTATeam_t.DOTA_TEAM_SPECTATOR)
		| (1 << DOTATeam_t.DOTA_TEAM_NEUTRALS)
		| (1 << DOTATeam_t.DOTA_TEAM_NOTEAM)
	) // don't check not existing team (0), spectators (1), neutrals (4) and noteam (5)

	let local_team = ent.m_iTeamNum,
		flags = ent.m_iTaggedAsVisibleByTeam & valid_teams

	for (let i = 14; i--; )
		if (i !== local_team && ((flags >> i) & 1))
			return true
	return false
}

export let IsTrueSightedForEnemies = (ent: C_DOTA_BaseNPC) => {
	return ent.m_ModifierManager.m_vecBuffs.some(buff => {
		if (buff === undefined || buff.m_bMarkedForDeletion)
			return false

		let name = buff.m_name
		if (name !== undefined)
			return false

		return [
			"modifier_truesight",
			"modifier_item_dustofappearance",
			"modifier_bloodseeker_thirst_vision",
			"modifier_bounty_hunter_track",
		].some(nameBuff => nameBuff === name)
	})
}

export let IsControllableByAnyPlayer = (ent: C_DOTA_BaseNPC) => ent.m_iIsControllableByPlayer64 !== 0n

export let HasScepter = (ent: C_DOTA_BaseNPC) => {
	if (ent.m_bStolenScepter)
		return true

	return ent.m_ModifierManager.m_vecBuffs.some(buff => {
		if (buff === undefined || buff.m_bMarkedForDeletion)
			return false

		let name = buff.m_name
		if (name !== undefined)
			return false

		return /modifier_item_ultimate_scepter|modifier_wisp_tether_scepter/.test(name)
	})
}

export function GetAbilityByName(ent: C_DOTA_BaseNPC, name: string): C_DOTABaseAbility {
	let abils = ent.m_hAbilities

	for (let i = 0, len = abils.length; i < len; i++) {
		let abil = (abils[i] as C_DOTABaseAbility)

		if (abil === undefined)
			continue

		if (abil.m_pAbilityData.m_pszAbilityName === name)
			return abil
	}

	return undefined
}

export function GetAbilityBySlot(ent: C_DOTA_BaseNPC, numSlot: number): C_DOTABaseAbility {
	return ent.m_hAbilities[numSlot] as C_DOTABaseAbility
}

export function GetItemByName(ent: C_DOTA_BaseNPC, name: string, icludeBackpack: boolean = false): C_DOTA_Item {

	let items = ent.m_Inventory.m_hItems,
		len = Math.min(items.length, icludeBackpack ? 9 : 6)

	for (let i = 0; i < len; i++) {
		let item = items[i] as C_DOTA_Item

		if (item === undefined)
			continue

		if (item.m_pAbilityData.m_pszAbilityName === name)
			return item
	}

	return undefined
}

export function GetItemByNameInBackpack(ent: C_DOTA_BaseNPC, name: string): C_DOTA_Item {

	let items = ent.m_Inventory.m_hItems,
		len = Math.min(items.length, 9)

	for (let i = 6; i < len; i++) {
		let item = items[i] as C_DOTA_Item

		if (item === undefined)
			continue

		if (item.m_pAbilityData.m_pszAbilityName === name)
			return item
	}

	return undefined
}

export function GetItemInSlot(ent: C_DOTA_BaseNPC, numSlot: number): C_DOTA_Item  {
	return ent.m_Inventory.m_hItems[numSlot] as C_DOTA_Item
}

export function GetBuffByName(ent: C_DOTA_BaseNPC, name: string): CDOTA_Buff {
	let buffs = ent.m_ModifierManager.m_vecBuffs,
		len = Math.min(buffs.length, 9)

	for (let i = 6; i < len; i++) {
		let buff = buffs[i] as CDOTA_Buff

		if (buff === undefined || buff.m_bMarkedForDeletion)
			continue

		if (buff.m_name === name)
			return buff
	}

	return undefined
}
export function IsControllableByPlayer(ent: C_DOTA_BaseNPC, playerID: number): boolean {
	return ((ent.m_iIsControllableByPlayer64 >> BigInt(playerID)) & 1n) === 1n
}

export function InFront(ent: C_BaseEntity, distance: number): Vector3 {
	return ent.m_vecNetworkOrigin.Rotation(ent.m_vecForward, distance)
}

export let IsHero = (ent: C_DOTA_BaseNPC) => (ent.m_iUnitType & 1) === 1
export let IsTower = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 2) & 1) === 1
export let IsConsideredHero = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 3) & 1) === 1
export let IsBuilding = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 4) & 1) === 1
export let IsFort = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 5) & 1) === 1
export let IsBarracks = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 6) & 1) === 1
export let IsCreep = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 7) & 1) === 1
export let IsCourier = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 8) & 1) === 1
export let IsShop = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 9) & 1) === 1
export let IsLaneCreep = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 10) & 1) === 1
export let IsShrine = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 12) & 1) === 1
export let IsWard = (ent: C_DOTA_BaseNPC) => ((ent.m_iUnitType >> 17) & 1) === 1

export function IsManaEnough(ent: C_DOTA_BaseNPC, abil: C_DOTABaseAbility) {
	return ent.m_flMana >= abil.m_iManaCost
}

export let IsIllusion = (ent: C_DOTA_BaseNPC_Hero) => ent.m_bIsIllusion || ent.m_hReplicatingOtherHeroModel !== null

export function SpellAmplification(ent: C_DOTA_BaseNPC): number {
	let spellAmp = 100

	if (ent instanceof C_DOTA_BaseNPC_Hero)
		spellAmp += ent.m_flIntellectTotal * 0.07 // https://dota2.gamepedia.com/Intelligence

	if (ent.m_bHasInventory) {
		let items = ent.m_Inventory.m_hItems as C_DOTA_Item[]

		for (let i = 0; i < 6; i++) {
			let item = items[i]
			if (item === undefined)
				continue
			spellAmp += item.GetSpecialValue("spell_amp")
		}
	}

	let abils = ent.m_hAbilities as C_DOTABaseAbility[]
	for (let i = 0, len = abils.length; i < len; i++) {
		let abil = abils[i]

		if (abil === undefined || abil.m_iLevel)
			continue

		let abilData = abil.m_pAbilityData
		if (abilData === undefined)
			continue

		let abilName = abilData.m_pszAbilityName
		if (abilName === undefined || !abilName.startsWith("special_bonus_spell_amplify"))
			continue

		spellAmp += abil.GetSpecialValue("value")
	}

	return spellAmp
}

export function IsInRange(ent: C_BaseEntity, entTo: C_BaseEntity, range: number): boolean {
	return ent.m_vecNetworkOrigin.Distance(entTo.m_vecNetworkOrigin) <= range
}

// ------------------------------- old utils

export function GetEntitiesInRange(vec: Vector3, range: number, onlyEnemies: boolean = false, findInvuln: boolean = false): C_DOTA_BaseNPC[] {
	var localplayer = LocalDOTAPlayer
	
	let ents = Entities.GetEntitiesInRange(vec, range).filter(ent =>
		ent instanceof C_DOTA_BaseNPC
		&& (!onlyEnemies || IsEnemy(ent, localplayer))
		&& IsAlive(ent)
		&& !(!findInvuln && IsUnitStateFlagSet(ent, modifierstate.MODIFIER_STATE_INVULNERABLE)),
	);
	
	return orderBy(ents, (ent: C_BaseEntity) => vec.Distance2D(ent.m_vecNetworkOrigin)) as C_DOTA_BaseNPC[]
}

export function GetItemByRegexp(ent: C_DOTA_BaseNPC, regex: RegExp): C_DOTA_Item {
	var found
	for (let i = 0; i < 6; i++) {
		const item = GetItemInSlot(ent, i)
		if (item === undefined)
			continue
		const name = item.m_pAbilityData.m_pszAbilityName
		if (name !== undefined && regex.test(name))
			return item
	}
	return undefined as any
}

export function GetItem(ent: C_DOTA_BaseNPC, name: string | RegExp): C_DOTA_Item {
	return name instanceof RegExp ? GetItemByRegexp(ent, name) : GetItemByName(ent, name)
}

export function GetAbilityByRegexp(ent: C_DOTA_BaseNPC, regex: RegExp): C_DOTABaseAbility {
	var found
	for (let i = 0; i < 24; i++) {
		const abil = GetAbilityBySlot(ent, i)
		if (abil === undefined)
			continue
		const name = abil.m_pAbilityData.m_pszAbilityName
		if (name !== undefined && regex.test(name))
			return abil
	}
	return undefined as any
}

export function GetAbility(ent: C_DOTA_BaseNPC, name: string | RegExp): C_DOTABaseAbility {
	return name instanceof RegExp ? GetAbilityByRegexp(ent, name) : GetAbilityByName(ent, name)
}

export function orderBy<T>(ar: T[], cb: (obj: T) => any): T[] {
	return ar.sort((a, b) => cb(a) - cb(b))
}

export function GetDamage(ent: C_DOTA_BaseNPC): number { return ent.m_iDamageMin + ent.m_iDamageBonus }

export function VelocityWaypoint(ent: C_DOTA_BaseNPC, time: number, movespeed: number = ent.m_bIsMoving ? ent.m_fIdealSpeed : 0): Vector3 {
	return InFront(ent, movespeed * time)
}

export function HasLinkenAtTime(ent: C_DOTA_BaseNPC, time: number = 0): boolean {
	if (!IsHero(ent))
		return false
	const sphere = GetItemByName(ent, "item_sphere")

	return (
		sphere !== undefined &&
		sphere.m_fCooldown - time <= 0
	) || (
		GetBuffByName(ent, "modifier_item_sphere_target") !== undefined
		&& GetBuffByName(ent, "modifier_item_sphere_target").m_flDieTime - GameRules.m_fGameTime - time <= 0
	)
}

export function SelectGroup(group: C_BaseEntity[], first: boolean = false): void {
	group.filter(ent => ent !== undefined).forEach(ent => {
		SelectUnit(ent, !first)
		first = false
	})
}

export function IsFlagSet(base: bigint, flag: bigint) {
	return (base & flag) > 0
}

export function GetProjectileDelay(source: C_DOTA_BaseNPC, target: C_DOTA_BaseNPC) {
	if (!HasAttackCapability(source, DOTAUnitAttackCapability_t.DOTA_UNIT_CAP_RANGED_ATTACK))
		return 0
	let proj_speed = source instanceof C_DOTA_BaseNPC_Hero ? projectile_speeds[source.m_iszUnitName] : 900
	if (proj_speed === undefined)
		return 0
	return (source.m_vecNetworkOrigin.Distance(target.m_vecNetworkOrigin) - source.m_flHullRadius - target.m_flHullRadius) / proj_speed
}

export function IsInside(npc: C_DOTA_BaseNPC, vec: Vector3, radius: number): boolean {
	const direction = npc.m_vecForward,
		npc_pos = npc.m_vecNetworkOrigin
	const npc_pos_x = npc_pos.x, npc_pos_y = npc_pos.y,
		vec_x = vec.x, vec_y = vec.y,
		direction_x = direction.x, direction_y = direction.y,
		radius_sqr = radius ** 2
	for (let i = Math.floor(vec.Distance2D(npc_pos) / radius) + 1; i--; )
		// if (npc_pos.Distance2D(new Vector3(vec.x - direction.x * i * radius, vec.y - direction.y * i * radius, vec.z - direction.z * i * radius)) <= radius)
		// optimized version, as V8 unable to optimize any native code by inlining
		if ((((vec_x - direction_x * i * radius - npc_pos_x) ** 2) + ((vec_y - direction_y * i * radius - npc_pos_y) ** 2)) <= radius_sqr)
			return true
	return false
}

const IgnoreBuffs = [
	[], // DAMAGE_TYPES.DAMAGE_TYPE_NONE = 0
	[ // DAMAGE_TYPES.DAMAGE_TYPE_PHYSICAL = 1
		"modifier_item_aeon_disk_buff",
	],
	[ // DAMAGE_TYPES.DAMAGE_TYPE_MAGICAL = 2
		"modifier_life_stealer_rage",
		"modifier_oracle_fates_edict",
		"modifier_medusa_stone_gaze",
		"modifier_juggernaut_blade_fury",
		"modifier_omniknight_repel",
		"modifier_item_aeon_disk_buff",
	],
	[],
	[], // DAMAGE_TYPES.DAMAGE_TYPE_PURE = 4
	[],
	[],
	[ // DAMAGE_TYPES.DAMAGE_TYPE_ALL = 7
		"modifier_abaddon_borrowed_time",
		"modifier_skeleton_king_reincarnation_scepter_active",
		"modifier_brewmaster_primal_split",
		"modifier_phoenix_supernova_hiding",
		"modifier_nyx_assassin_spiked_carapace",
		"modifier_templar_assassin_refraction_absorb",
		"modifier_oracle_false_promise",
		"modifier_dazzle_shallow_grave",
		"modifier_treant_living_armor",
		"modifier_item_aegis",
		"modifier_tusk_snowball_movement",
		"modifier_eul_cyclone",
		"modifier_necrolyte_reapers_scythe",
		"modifier_riki_tricks_of_the_trade_phase",
		"modifier_ember_spirit_sleight_of_fist_caster_invulnerability",
		"modifier_puck_phase_shift",
	],
	[], // DAMAGE_TYPES.DAMAGE_TYPE_HP_REMOVAL = 8
]
IgnoreBuffs.map((ar, i) => { // optimization & beauty trick
	if (i === DAMAGE_TYPES.DAMAGE_TYPE_NONE || i === DAMAGE_TYPES.DAMAGE_TYPE_ALL)
		return ar
	return ar.concat(IgnoreBuffs[DAMAGE_TYPES.DAMAGE_TYPE_ALL])
})

export function AbsorbedDamage(target: C_DOTA_BaseNPC, dmg: number, damage_type: DAMAGE_TYPES, source?: C_DOTA_BaseNPC): number {
	target.m_ModifierManager.m_vecBuffs.forEach(buff => {
		let abil = buff.m_hAbility as C_DOTABaseAbility
		if (abil === undefined)
			return
		if (damage_type === DAMAGE_TYPES.DAMAGE_TYPE_MAGICAL)
			switch (buff.m_name) {
				case "modifier_ember_spirit_flame_guard": {
					let talent = GetAbilityByName(target, "special_bonus_unique_ember_spirit_1")
					if (talent !== undefined && talent.m_iLevel > 0)
						dmg -= talent.GetSpecialValue("value")
					dmg -= abil.GetSpecialValue("absorb_amount")
					return
				}
				case "modifier_item_pipe_barrier":
				case "modifier_item_hood_of_defiance_barrier":
				case "modifier_item_infused_raindrop":
					dmg -= abil.GetSpecialValue("barrier_block")
					return
				default:
					break
			}
		switch (abil.m_pAbilityData.m_pszAbilityName) {
			case "abaddon_aphotic_shield": {
				let talent = GetAbilityByName(target, "special_bonus_unique_abaddon")
				if (talent !== undefined && talent.m_iLevel > 0)
					dmg -= talent.GetSpecialValue("value")
				dmg -= abil.GetSpecialValue("damage_absorb")
				return
			}
			case "bloodseeker_bloodrage":
				dmg *= abil.GetSpecialValue("damage_increase_pct") / 100
				return
			case "spectre_dispersion":
				dmg *= 1 - (abil.GetSpecialValue("damage_reflection_pct") / 100)
				return
			case "ursa_enrage":
			case "centaur_stampede":
				dmg *= 1 - (abil.GetSpecialValue("damage_reduction") / 100)
				return
			case "kunkka_ghostship":
				dmg *= 1 - (abil.GetSpecialValue("ghostship_absorb") / 100)
				return
			case "wisp_overcharge":
				dmg *= 1 + (abil.GetSpecialValue("bonus_damage_pct") / 100)
				return
			case "medusa_mana_shield": {
				let max_absorbed_dmg = this.m_flMana * abil.GetSpecialValue("damage_per_mana"),
					possible_absorbed = dmg * abil.GetSpecialValue("absorption_tooltip") / 100
				dmg -= Math.min(max_absorbed_dmg, possible_absorbed)
				return
			}
			case "bristleback_bristleback": {
				if (source !== undefined) {
					let rot_angle = source.m_vecNetworkOrigin.FindRotationAngle(target)
					if (rot_angle > 1.90)
						dmg *= 1 - abil.GetSpecialValue("back_damage_reduction") / 100
					else if (rot_angle > 1.20)
						dmg *= 1 - abil.GetSpecialValue("side_damage_reduction") / 100
				}
				return
			}
			default:
				return
		}
	})
	return dmg
}

export function WillIgnore(target: C_DOTA_BaseNPC, damage_type: DAMAGE_TYPES): boolean {
	if (damage_type === DAMAGE_TYPES.DAMAGE_TYPE_NONE)
		return true

	let ignore_buffs = IgnoreBuffs[damage_type]
	return target.m_ModifierManager.m_vecBuffs.some(buff => {
		let name = buff.m_name
		if (name === undefined)
			return false
		return ignore_buffs.includes(name)
	})
}

export function CalculateDamage(target: C_DOTA_BaseNPC, damage: number, damage_type: DAMAGE_TYPES, source?: C_DOTA_BaseNPC): number {
	if (damage <= 0 || WillIgnore(target, damage_type))
		return 0
	damage = AbsorbedDamage(target, damage, damage_type, source)
	if (damage <= 0)
		return 0
	switch (damage_type) {
		case DAMAGE_TYPES.DAMAGE_TYPE_MAGICAL:
			damage *= 1 - target.m_flMagicalResistanceValue / 100
			break
		case DAMAGE_TYPES.DAMAGE_TYPE_PHYSICAL: {
			let armor = target.m_flPhysicalArmorValue
			damage *= Math.max(Math.min((1 - (0.052 * armor) / (0.9 + 0.048 * armor)), 2), 0)
			{
				let phys_damage_type = source === undefined ? AttackDamageType.Basic : source.m_iCombatClassAttack as AttackDamageType,
					phys_armor_type = target.m_iCombatClassDefend as ArmorType
				if (phys_damage_type === AttackDamageType.Hero && phys_armor_type === ArmorType.Structure)
					damage *= .5
				else if (phys_damage_type === AttackDamageType.Basic && phys_armor_type === ArmorType.Hero)
					damage *= .75
				else if (phys_damage_type === AttackDamageType.Basic && phys_armor_type === ArmorType.Structure)
					damage *= .7
				else if (phys_damage_type === AttackDamageType.Pierce && phys_armor_type === ArmorType.Hero)
					damage *= .5
				else if (phys_damage_type === AttackDamageType.Pierce && phys_armor_type === ArmorType.Basic)
					damage *= 1.5
				else if (phys_damage_type === AttackDamageType.Pierce && phys_armor_type === ArmorType.Structure)
					damage *= .35
				else if (phys_damage_type === AttackDamageType.Siege && phys_armor_type === ArmorType.Hero)
					damage *= .85
				else if (phys_damage_type === AttackDamageType.Siege && phys_armor_type === ArmorType.Structure)
					damage *= 2.5
			}
			break
		}
		default:
			break
	}
	return Math.max(damage, 0)
}

export function CalculateDamageByHand(target: C_DOTA_BaseNPC, source: C_DOTA_BaseNPC): number {
	if (GetBuffByName(source, "modifier_tinker_laser_blind") !== undefined || WillIgnore(target, DAMAGE_TYPES.DAMAGE_TYPE_PHYSICAL))
		return 0
	let mult = 1
	{
		let damage_type = source.m_iCombatClassAttack as AttackDamageType,
			armor_type = target.m_iCombatClassDefend as ArmorType
		if (damage_type === AttackDamageType.Hero && armor_type === ArmorType.Structure)
			mult *= .5
		else if (damage_type === AttackDamageType.Basic && armor_type === ArmorType.Hero)
			mult *= .75
		else if (damage_type === AttackDamageType.Basic && armor_type === ArmorType.Structure)
			mult *= .7
		else if (damage_type === AttackDamageType.Pierce && armor_type === ArmorType.Hero)
			mult *= .5
		else if (damage_type === AttackDamageType.Pierce && armor_type === ArmorType.Basic)
			mult *= 1.5
		else if (damage_type === AttackDamageType.Pierce && armor_type === ArmorType.Structure)
			mult *= .35
		else if (damage_type === AttackDamageType.Siege && armor_type === ArmorType.Hero)
			mult *= .85
		else if (damage_type === AttackDamageType.Siege && armor_type === ArmorType.Structure)
			mult *= 2.5
	}
	let damage = source.m_iDamageMin + source.m_iDamageBonus
	damage = AbsorbedDamage(target, damage, DAMAGE_TYPES.DAMAGE_TYPE_PHYSICAL)
	if (damage <= 0)
		return 0
	let buffs = target.m_ModifierManager.m_vecBuffs.map(buff => [buff, buff.m_name]) as Array<[CDOTA_Buff, string]>,
		items = (source.m_Inventory.m_hItems.filter(item => item !== undefined) as C_DOTA_Item[]).map(item => [item, item.m_pAbilityData.m_pszAbilityName] )as Array<[C_DOTA_Item, string]>,
		abils = (source.m_hAbilities.filter(abil => abil !== undefined) as C_DOTABaseAbility[]).map(abil => [abil, abil.m_pAbilityData.m_pszAbilityName] )as Array<[C_DOTABaseAbility, string]>,
		armor = target.m_flPhysicalArmorValue,
		is_enemy = IsEnemy(target, source),
		is_hero = source instanceof C_DOTA_BaseNPC_Hero
	if (is_enemy) {
		{
			if (!buffs.some(([buff_, name]) => name === "modifier_blight_stone_buff")) {
				let item = items.find(([item_, name]) => name === "item_blight_stone")
				if (item !== undefined)
					armor += item[0].GetSpecialValue("corruption_armor")
			}
		}
		{
			if (!buffs.some(([buff_, name]) => name === "modifier_desolator_buff")) {
				let item = items.find(([item_, name]) => name === "item_desolator")
				if (item !== undefined)
					armor += item[0].GetSpecialValue("corruption_armor")
			}
		}
		{
			let item = items.find(([item_, name]) => name === "item_quelling_blade")
			if (item !== undefined)
				damage += item[0].GetSpecialValue(HasAttackCapability(source, DOTAUnitAttackCapability_t.DOTA_UNIT_CAP_RANGED_ATTACK) ? "damage_bonus_ranged" : "damage_bonus")
		}
		{
			let item = items.find(([item_, name]) => name === "item_bfury")
			if (item !== undefined)
				damage += item[0].GetSpecialValue(HasAttackCapability(source, DOTAUnitAttackCapability_t.DOTA_UNIT_CAP_RANGED_ATTACK) ? "damage_bonus_ranged" : "damage_bonus")
		}
		{
			let abil = abils.find(([abil_, name]) => name === "clinkz_searing_arrows")
			if (abil !== undefined && abil[0].m_bAutoCastState && IsManaEnough(source, abil[0]))
				damage += abil[0].GetSpecialValue("damage_bonus")
		}
		{
			let abil = abils.find(([abil_, name]) => name === "antimage_mana_break")
			if (abil !== undefined && target.m_flMaxMana > 0)
				damage += Math.min(target.m_flMana, abil[0].GetSpecialValue("mana_per_hit")) * abil[0].GetSpecialValue("damage_per_burn")
		}
		{
			let abil = abils.find(([abil_, name]) => name === "ursa_fury_swipes")
			if (abil !== undefined) {
				let buff = buffs.find(([buff_, name]) => name === "modifier_ursa_fury_swipes_damage_increase")
				damage += abil[0].GetSpecialValue("damage_per_stack") * (1 + (buff !== undefined ? buff[0].m_iStackCount : 0))
			}
		}
		{
			let abil = abils.find(([abil_, name]) => name === "bounty_hunter_jinada")
			if (abil !== undefined && abil[0].m_fCooldown === 0)
				damage += abil[0].GetSpecialValue("bonus_damage")
		}
	}
	{
		let abil = abils.find(([item, name]) => name === "kunkka_tidebringer")
		if (abil !== undefined && abil[0].m_bAutoCastState && abil[0].m_fCooldown === 0)
			damage += abil[0].GetSpecialValue("damage_bonus")
	}
	{
		let buff = GetBuffByName(source, "modifier_storm_spirit_overload_passive")
		if (buff !== undefined) {
			let abil = buff.m_hAbility as C_DOTABaseAbility
			if (abil !== undefined)
				damage += abil.m_iAbilityDamage
		}
	}
	{
		let abil = abils.find(([item, name]) => name === "riki_permanent_invisibility")
		if (abil !== undefined && (source.m_vecForward.AngleBetweenFaces(target.m_vecForward) * 180 / Math.PI) < abil[0].GetSpecialValue("backstab_angle"))
			damage += abil[0].GetSpecialValue("damage_multiplier") * (source as C_DOTA_BaseNPC_Hero).m_flAgilityTotal
	}
	damage *= 1 - (armor * 0.05) / (1 + Math.abs(armor) * 0.05)
	if (is_enemy) {
		{
			let abil = abils.find(([item, name]) => name === "silencer_glaives_of_wisdom")
			if (abil !== undefined && abil[0].m_bAutoCastState && IsManaEnough(source, abil[0]))
				damage += abil[0].GetSpecialValue("intellect_damage_pct") * (source as C_DOTA_BaseNPC_Hero).m_flIntellectTotal / 100
		}
		{
			let abil = abils.find(([item, name]) => name === "obsidian_destroyer_arcane_orb")
			if (abil !== undefined && abil[0].m_bAutoCastState && IsManaEnough(source, abil[0]))
				damage += abil[0].GetSpecialValue("mana_pool_damage_pct") * (source as C_DOTA_BaseNPC_Hero).m_flMaxMana / 100
		}
	}
	{
		let abil = abils.find(([item, name]) => name === "spectre_desolate")
		if (abil !== undefined)
			damage += abil[0].GetSpecialValue("bonus_damage")
	}
	{
		let buff = GetBuffByName(source, "modifier_bloodseeker_bloodrage")
		if (buff !== undefined) {
			let abil = buff.m_hAbility as C_DOTABaseAbility
			if (abil !== undefined)
				mult *= 1 + abil.GetSpecialValue("damage_increase_pct") / 100
		}
	}
	{
		let buff = buffs.find(([buff_, name]) => name === "modifier_bloodseeker_bloodrage")
		if (buff !== undefined) {
			let abil = buff[0].m_hAbility as C_DOTABaseAbility
			if (abil !== undefined)
				mult *= 1 + abil.GetSpecialValue("damage_increase_pct") / 100
		}
	}

	return Math.max(damage * mult, 0)
}

export function GetHealthAfter(ent: C_DOTA_BaseNPC, delay: number, include_projectiles: boolean = false, attacker?: C_DOTA_BaseNPC, melee_time_offset: number = 0): number {
	let cur_time = GameRules.m_fGameTime,
		hpafter = ent.m_iHealth
	// loop-optimizer: KEEP
	attacks.forEach((data, attacker_id) => {
		let attacker_ent = Entities.GetEntityByID(attacker_id) as C_DOTA_BaseNPC,
			[end_time, end_time_2, attack_target] = data
		if (attacker_ent !== attacker && attack_target === ent) {
			let end_time_delta = end_time - (cur_time + delay + melee_time_offset),
				dmg = CalculateDamageByHand(ent, attacker_ent)
			if (end_time_delta <= 0 && end_time_delta >= -melee_end_time_delta)
				hpafter -= dmg
			let end_time_2_delta = end_time_2 - (cur_time + delay + melee_time_offset)
			if (end_time_2_delta <= 0 && end_time_2_delta >= -melee_end_time_delta)
				hpafter -= dmg
		}
	})
	if (include_projectiles)
		Projectiles.GetAllTracking().forEach(proj => {
			let source = proj.m_hSource
			if (proj.m_hTarget === ent && source !== undefined && proj.m_bIsAttack && !proj.m_bIsEvaded && (proj.m_vecPosition.Distance(proj.m_vecTarget) / proj.m_iSpeed) <= delay)
				hpafter -= CalculateDamageByHand(ent, source)
		})
	return Math.min(hpafter + ent.m_flHealthThinkRegen * delay, ent.m_iMaxHealth)
}

export function IsDeniable(target: C_DOTA_BaseNPC): boolean {
	let hp_percent = target.m_iHealth / target.m_iMaxHealth
	if (hp_percent > 0.5) // nothing can be denied w/o losing half of max HP, so we'd skip unnecessary checks
		return false
	if (target instanceof C_DOTA_BaseNPC_Creep)
		return hp_percent <= 0.5
	if (target instanceof C_DOTA_BaseNPC_Tower)
		return hp_percent <= 0.1

	if (hp_percent >= 0.25)
		return false
	return target.m_ModifierManager.m_vecBuffs.map(buff => buff.m_name).some(name =>
		name === "modifier_doom_bringer_doom"
		|| name === "modifier_queenofpain_shadow_strike"
		|| name === "modifier_venomancer_venomous_gale",
	)
}

export function FindAttackingUnit(npc: C_DOTA_BaseNPC): C_DOTA_BaseNPC {
	if (npc === undefined)
		return undefined
	let pos = npc.m_vecNetworkOrigin,
		is_default_creep = IsCreep(npc) && !IsControllableByAnyPlayer(npc)
	return orderBy(AllEntities.filter(npc_ => {
		if (npc_ === npc || !(npc_ instanceof C_DOTA_BaseNPC))
			return false
		let npc_pos = npc_.m_vecNetworkOrigin
		return (
			npc_pos.Distance2D(pos) <= (npc.m_fAttackRange + npc.m_flHullRadius + npc_.m_flHullRadius) &&
			!IsUnitStateFlagSet(npc, modifierstate.MODIFIER_STATE_INVULNERABLE) &&
			IsInside(npc, npc_pos, npc_.m_flHullRadius) &&
			(IsEnemy(npc, npc_) || (!is_default_creep && IsDeniable(npc_)))
		)
	}), ent => GetAngle(npc, ent.m_vecNetworkOrigin))[0] as C_DOTA_BaseNPC
}

export function GetAngle(npc: C_DOTA_BaseNPC, vec: Vector3): number {
	let npc_pos = npc.m_vecNetworkOrigin,
		angle = Math.abs(Math.atan2(npc_pos.y - vec.y, npc_pos.x - vec.x) - npc.m_vecForward.Angle)
	if (angle > Math.PI)
		angle = Math.abs((Math.PI * 2) - angle)
	return angle
}

let turn_rad = Math.PI - 0.25
export function GetRotationTime(npc: C_DOTA_BaseNPC, vec: Vector3): number {
	let ang = GetAngle(npc, vec)
	if (ang > turn_rad) // <= (360-45)deg
		return 0
	return 30 * ang / rotation_speed[npc.m_iszUnitName]
}

export function GetCastRangeBonus(npc: C_DOTA_BaseNPC) {
	let bonus = 0,
		lens = GetItemByName(npc, "item_aether_lens")
	if (lens !== undefined)
		bonus += lens.GetSpecialValue("cast_range_bonus");
	// loop-optimizer: POSSIBLE_UNDEFINED
	(npc.m_hAbilities as C_DOTABaseAbility[]).forEach(abil => {
		if (abil.m_iLevel > 0)
			return
		let abil_data = abil.m_pAbilityData
		if (abil_data !== undefined) {
			let abil_name = abil_data.m_pszAbilityName
			if (abil_name !== undefined && abil_name.startsWith("special_bonus_cast_range_"))
				bonus += abil.GetSpecialValue("value")
		}
	})
	return bonus
}

export function GetCastRange(npc: C_DOTA_BaseNPC, abil: C_DOTABaseAbility) {
	let abil_data = abil.m_pAbilityData,
		cast_range = abil.m_iCastRange
	if (abil_data !== undefined) {
		let abil_name = abil_data.m_pszAbilityName,
			talent: C_DOTABaseAbility
		switch (abil_name) {
			case "skywrath_mage_concussive_shot":
				talent = GetAbilityByName(npc, "special_bonus_unique_skywrath_4")
				if (talent !== undefined && talent.m_iLevel > 0)
					return Number.MAX_SAFE_INTEGER
				break
			case "gyrocopter_call_down":
				talent = GetAbilityByName(npc, "special_bonus_unique_gyrocopter_5")
				if (talent !== undefined && talent.m_iLevel > 0)
					return Number.MAX_SAFE_INTEGER
				break
			case "lion_impale":
				talent = GetAbilityByName(npc, "special_bonus_unique_lion_2")
				if (talent !== undefined && talent.m_iLevel > 0)
					cast_range += talent.GetSpecialValue("value")
				break
			default:
				break
		}
	}
	return cast_range + GetCastRangeBonus(npc)
}

export function IntersectArrays<T>(a: T[], b: T[]) {
	return a.some(val1 => b.some(val2 => val1 === val2))
}

export function GetOrdersWithoutSideEffects() {
	return [
		dotaunitorder_t.DOTA_UNIT_ORDER_TRAIN_ABILITY,
		dotaunitorder_t.DOTA_UNIT_ORDER_CAST_TOGGLE,
		dotaunitorder_t.DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO,
		dotaunitorder_t.DOTA_UNIT_ORDER_PURCHASE_ITEM,
		dotaunitorder_t.DOTA_UNIT_ORDER_DISASSEMBLE_ITEM,
		dotaunitorder_t.DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK,
		dotaunitorder_t.DOTA_UNIT_ORDER_SELL_ITEM,
		dotaunitorder_t.DOTA_UNIT_ORDER_MOVE_ITEM,
		dotaunitorder_t.DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH,
		dotaunitorder_t.DOTA_UNIT_ORDER_CONTINUE, // Announce?
		dotaunitorder_t.DOTA_UNIT_ORDER_GLYPH,
		dotaunitorder_t.DOTA_UNIT_ORDER_RADAR,
	]
}

export function GetCursorWorldVec() {
	return CursorWorldVec
}

export function arrayRemove<T>(ar: T[], el: T) {
	const id = ar.indexOf(el)
	if (id !== -1)
		ar.splice(id, 1)
}

Events.on("onSendMove", cmd => CursorWorldVec = cmd.vec_under_cursor)

Events.on("onEntityDestroyed", (ent, ent_id) => {
	// loop-optimizer: KEEP
	attacks = attacks.filter((data, attacker_id) => attacker_id !== ent_id && data[2] !== ent)
})

Events.on("onUnitAnimation", (npc, sequenceVariant, playbackrate, castpoint, type, activity) => {
	if (activity === 1503 && !HasAttackCapability(npc, DOTAUnitAttackCapability_t.DOTA_UNIT_CAP_RANGED_ATTACK)) {
		let delay = (1 / npc.m_fAttacksPerSecond) - 0.06
		attacks[Entities.GetEntityID(npc)] = [
			GameRules.m_fGameTime + delay,
			IsCreep(npc) ? GameRules.m_fGameTime + delay * 2 + 0.06 : Number.MAX_VALUE,
			FindAttackingUnit(npc),
		]
	}
})

Events.on("onUnitAnimationEnd", npc => {
	let id = Entities.GetEntityID(npc)
	let found = attacks[id]
	if (found === undefined)
		return
	let [end_time, end_time_2, attack_target] = found
	if (attack_target === undefined || !IsCreep(npc) || IsControllableByAnyPlayer(npc) || !attack_target.m_bIsValid || !IsAlive(attack_target) || !IsVisible(attack_target)) {
		delete attacks[id]
		return
	}
	let delay = (1 / npc.m_fAttacksPerSecond) + 0.06
	attacks[id] = [
		GameRules.m_fGameTime + delay,
		GameRules.m_fGameTime + delay * 2 - 0.06,
		attack_target,
	]
})

Events.on("onGameEnded", () => attacks = [])

Events.on("onTick", () => {
	// attack sanitizer
	let time = GameRules.m_fGameTime
	// loop-optimizer: KEEP
	attacks = attacks.filter(([end_time, end_time_2, attack_target]) => time - end_time_2 <= melee_end_time_delta)
	// loop-optimizer: KEEP
	attacks.forEach((data, attacker_id) => data[2] = FindAttackingUnit(Entities.GetEntityByID(attacker_id) as C_DOTA_BaseNPC))
})
