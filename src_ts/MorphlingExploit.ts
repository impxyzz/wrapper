import { MenuManager, LocalPlayer, Vector3, EntityManager, Utils, Ability, Item, Unit } from "./CrutchesSDK/Imports"

var CursorWorldVec = new Vector3()
Events.on("onUpdate", cmd => CursorWorldVec = Vector3.fromIOBuffer(cmd.vec_under_cursor))

function GetBuggedAbils(): C_DOTABaseAbility[] {
	let hero = LocalDOTAPlayer.m_hAssignedHero as C_DOTA_BaseNPC
	let spells = hero.m_hAbilities.filter(abil => abil !== undefined)
	return Entities.AllEntities.filter(ent =>
		ent instanceof C_DOTABaseAbility
		&& !(ent instanceof C_DOTA_Ability_Morphling_Waveform)
		&& !(ent instanceof C_DOTA_Item)
		&& (ent.m_pAbilityData.m_iAbilityBehavior & BigInt(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_PASSIVE)) === 0n
		&& ent.m_hOwnerEntity === hero
		&& !spells.includes(ent)
	) as C_DOTABaseAbility[]
}

function castabil(id: number) {
	if (!IsInGame() || !LocalPlayer.HeroAssigned)
		return
	let abils = GetBuggedAbils()
	if (id >= abils.length)
		return
	let abil = EntityManager.GetEntityByNative(abils[id]) as Ability
	let target = Utils.orderBy(EntityManager.GetEntitiesInRange(CursorWorldVec, 500).filter(ent => {
		return (
			(
				(abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_FRIENDLY) && !ent.IsEnemy())
				|| (abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_ENEMY) && ent.IsEnemy())
				|| abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_CUSTOM)
				|| abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_BOTH)
			)
			&& (
				abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_ALL)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_BUILDING) && ent.IsBuilding)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_COURIER) && ent.IsCourier)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_CREEP) && ent.IsCreep)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_HERO) && ent.IsHero)
			)
		)
	}), ent => ent.Distance(CursorWorldVec))[0]
	let native_target = target !== undefined ? target.m_pBaseEntity : undefined
	CursorWorldVec.toIOBuffer()

	let beh = abil.AbilityBehavior
	PrepareUnitOrders({
		OrderType: beh.includes(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_NO_TARGET)
					? dotaunitorder_t.DOTA_UNIT_ORDER_CAST_NO_TARGET
					: native_target !== undefined && (beh.includes(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_UNIT_TARGET) || beh.length === 0)
						? dotaunitorder_t.DOTA_UNIT_ORDER_CAST_TARGET
						: beh.includes(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_POINT)
							? dotaunitorder_t.DOTA_UNIT_ORDER_CAST_POSITION
							: dotaunitorder_t.DOTA_UNIT_ORDER_CAST_NO_TARGET,
		Ability: abil.m_pBaseEntity,
		Queue: false,
		ShowEffects: true,
		Unit: LocalDOTAPlayer.m_hAssignedHero,
		Target: native_target
	})
}

const Menu = MenuManager.MenuFactory("Morphling Exploit");
for (let i = 0; i < 10; i++)
	Menu.AddKeybind("Hotkey " + (i + 1)).OnPressed(() => castabil(i))
const alwaysHotkey = Menu.AddKeybind("Hotkey hold")
const alwaysHotkeySlider = Menu.AddSlider("Hotkey hold number", 0, 0, 20)
const xOffset = Menu.AddSlider("X Offset", 0, 0, 10000);
const yOffset = Menu.AddSlider("Y Offset", 200, 0, 10000);
const fontSize = Menu.AddSlider("Font size", 16, 0, 100);

Events.on("onDraw", () => {
	if (!IsInGame() || LocalDOTAPlayer === undefined || LocalDOTAPlayer.m_hAssignedHero === undefined)
		return
	let abils = GetBuggedAbils()
	// loop-optimizer: KEEP
	abils.forEach((abil, i) => Renderer.Text (
		xOffset.value,
		yOffset.value + i * fontSize.value,
		`${abil.m_pAbilityData.m_pszAbilityName} ${abil.m_fCooldown.toFixed(1)}`,
		255, 255, 255, 255, "Calibri", fontSize.value
	))
})

setInterval(() => {
	if (!IsInGame() || LocalDOTAPlayer === undefined || LocalDOTAPlayer.m_hAssignedHero === undefined)
		return
	if (alwaysHotkey.IsPressed)
		castabil(alwaysHotkeySlider.value)
}, 30)
