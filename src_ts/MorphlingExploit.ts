import { Ability, ArrayExtensions, EntityManager, Game, MenuManager, Unit, Utils, RendererSDK, Vector2, Color } from "./wrapper/Imports"

var available_at = 0

function GetBuggedAbils(hero: C_DOTA_Unit_Hero_Morphling): C_DOTABaseAbility[] {
	let spells = hero.m_hAbilities.filter(abil => abil !== undefined)
	let ar = Entities.AllEntities.filter(ent =>
		ent instanceof C_DOTABaseAbility
		&& !(ent instanceof C_DOTA_Ability_Morphling_Waveform)
		&& !(ent instanceof C_DOTA_Item)
		&& (ent.m_pAbilityData.m_iAbilityBehavior & BigInt(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_PASSIVE)) === 0n
		&& ent.m_hOwnerEntity === hero
		&& !spells.includes(ent),
	) as C_DOTABaseAbility[]
	let ar2 = []
	let obj = []
	ArrayExtensions.orderBy(ar, abil => -abil.m_iLevel).forEach(abil => abil instanceof C_DOTA_Ability_LoneDruid_SpiritBear ? ar2.push(abil) : obj[abil.m_pAbilityData.m_pszAbilityName] = abil)
	return [...Object.values(obj), ...ar2]
}

function castabil(id: number) {
	if (!IsInGame() || available_at > Game.RawGameTime)
		return
	let hero = Entities.AllEntities.find(ent => ent instanceof C_DOTA_Unit_Hero_Morphling) as C_DOTA_Unit_Hero_Morphling
	if (hero === undefined)
		return
	let abils = GetBuggedAbils(hero)
	if (id >= abils.length)
		return
	let abil = EntityManager.GetEntityByNative(abils[id]) as Ability
	let target = ArrayExtensions.orderBy(EntityManager.GetEntitiesInRange(Utils.CursorWorldVec, 200).filter(ent => {
		return (
			(
				ent.IsVisible
				&& ent.IsAlive
				&& (!(ent instanceof Unit) || !ent.m_pBaseEntity.m_bIsWaitingToSpawn)
			)
			&& (
				(abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_FRIENDLY) && !ent.IsEnemy())
				|| (abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_ENEMY) && ent.IsEnemy())
				|| abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_CUSTOM)
				|| abil.TargetTeam.includes(DOTA_UNIT_TARGET_TEAM.DOTA_UNIT_TARGET_TEAM_BOTH)
			)
			&& (
				abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_ALL)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_BUILDING) && ent.IsBuilding)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_COURIER) && ent.IsCourier)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_CREEP) && ent.IsCreep)
				|| (ent instanceof Unit && abil.TargetType.includes(DOTA_UNIT_TARGET_TYPE.DOTA_UNIT_TARGET_HERO) && ent.IsHero)
			)
		)
	}), ent => ent.Distance(Utils.CursorWorldVec))[0]
	let native_target = target !== undefined ? target.m_pBaseEntity : undefined
	Utils.CursorWorldVec.toIOBuffer()

	let beh = abil.AbilityBehavior
	PrepareUnitOrders({
		OrderType: beh.includes(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_NO_TARGET)
					? dotaunitorder_t.DOTA_UNIT_ORDER_CAST_NO_TARGET
					: native_target !== undefined && (beh.includes(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_UNIT_TARGET) || beh.length === 0)
						? dotaunitorder_t.DOTA_UNIT_ORDER_CAST_TARGET
						: beh.includes(DOTA_ABILITY_BEHAVIOR.DOTA_ABILITY_BEHAVIOR_POINT)
							? dotaunitorder_t.DOTA_UNIT_ORDER_CAST_POSITION
							: dotaunitorder_t.DOTA_UNIT_ORDER_CAST_NO_TARGET,
		Ability: abil.m_pBaseEntity,
		Queue: false,
		ShowEffects: true,
		Unit: hero,
		Target: native_target,
	})
	available_at = Game.RawGameTime + abil.CastPoint + 0.01
}

const Menu = MenuManager.MenuFactory("Morphling Exploit")
const enableHUD = Menu.AddToggle("Enable HUD", true)
for (let i = 0; i < 10; i++)
	Menu.AddKeybind("Hotkey " + (i + 1)).OnPressed(() => castabil(i))
const alwaysHotkey = Menu.AddKeybind("Hotkey hold")
const alwaysHotkeySlider = Menu.AddSlider("Hotkey hold number", 0, 0, 20)
const xOffset = Menu.AddSlider("X Offset", 0, 0, 10000)
const yOffset = Menu.AddSlider("Y Offset", 200, 0, 10000)
const fontSize = Menu.AddSlider("Font size", 30, 0, 100)

Events.on("Draw", () => {
	if (!IsInGame())
		return
	let hero = Entities.AllEntities.find(ent => ent instanceof C_DOTA_Unit_Hero_Morphling) as C_DOTA_Unit_Hero_Morphling
	if (hero === undefined)
		return
	let abils = GetBuggedAbils(hero)
	for (let i = abils.length; i--; )
		if (abils[i] instanceof C_DOTA_Ability_LoneDruid_SpiritBear || abils[i] instanceof C_DOTA_Ability_MonkeyKing_TreeDance) {
			let j = 30
			while (hero.m_hAbilities[--j] !== undefined);
			hero.m_hAbilities[j] = abils[i]
		}
	if (enableHUD.value) {
		// loop-optimizer: KEEP
		abils.forEach((abil, i) => RendererSDK.Text (
			`${abil.m_pAbilityData.m_pszAbilityName} ${abil.m_fCooldown.toFixed(1)}`,
			new Vector2 (
				xOffset.value,
				yOffset.value + i * fontSize.value
			),
			new Color(255, 255, 255),
			"Calibri",
			fontSize.value,
		))
	}
})

Events.on("PrepareUnitOrders", order => {
	if (order.order_type === dotaunitorder_t.DOTA_UNIT_ORDER_STOP)
		available_at = Game.RawGameTime
})
Events.on("GameEnded", () => available_at = 0)

setInterval(() => {
	if (!IsInGame())
		return
	if (alwaysHotkey.IsPressed)
		castabil(alwaysHotkeySlider.value)
}, 30)
