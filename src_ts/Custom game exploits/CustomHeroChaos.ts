import { EventsSDK, Menu, EntityManager, Player, ArrayExtensions, Hero, Utils, Parse, LocalPlayer } from "wrapper/Imports"
let root = Menu.AddEntry(["Utility", "Custom game exploits", "Custom Hero Chaos"])
let showed_heroes = root.AddNode("Heroes")
let show_heroes = root.AddImageSelector("Heroes to show", [])
let players = root.AddImageSelector("Players to spend gold", [])
let ability_replace = root.AddImageSelector("Ability to replace", [])
let roll_ability = root.AddButton("Roll ability")
let hero_ability_list: { [key: string]: string[] } = {}
let enabled_ability_list = new Map<string, boolean>()

/*let abilityExclusion = new Map([
	["lone_druid_true_form", "lone_druid_spirit_bear"],
	["lone_druid_spirit_bear", "lone_druid_true_form"],
	["dazzle_bad_juju", "puck_phase_shift"],
	["puck_phase_shift", "dazzle_bad_juju"],
	["dazzle_bad_juju", "dark_willow_shadow_realm"],
	["dark_willow_shadow_realm", "dazzle_bad_juju"],
	["drow_ranger_marksmanship", "faceless_void_time_lock"],
	["faceless_void_time_lock", "drow_ranger_marksmanship"],
])
let heroExclusion = new Map([
	["npc_dota_hero_drow_ranger", ["dazzle_bad_juju", "puck_phase_shift", "dark_willow_shadow_realm"]],
	["npc_dota_hero_nevermore", ["dazzle_bad_juju", "puck_phase_shift", "dark_willow_shadow_realm"]],
])
let abilityPersonal = new Map([
	["zuus_static_field", "npc_dota_hero_zuus"],
	["legion_commander_moment_of_courage", "npc_dota_hero_legion_commander"],
])*/
let unremovableAbilities = ["shredder_chakram", "monkey_king_wukongs_command", "elder_titan_ancestral_spirit"]

EventsSDK.on("GameStarted", () => {
	players.enabled_values.clear() // reset state every game since it's based on playerIDs
	let kv = Utils.parseKVFile("scripts/npc/npc_abilities_list.txt")
	if (kv.size === 0)
		return
	show_heroes.values = []
	hero_ability_list = {}
	let CustomAbilities = kv.get("CustomAbilities") as Parse.RecursiveMap
	// loop-optimizer: KEEP
	CustomAbilities.forEach((val, key) => {
		if (!(val instanceof Map))
			return
		let ar: string[] = []
		// loop-optimizer: KEEP
		val.forEach((val_, key_) => {
			if (val_ instanceof Map)
				return
			ar.push(val_)
		})
		hero_ability_list[key] = ar
		show_heroes.values.push(`npc_dota_hero_${key}`)
	})
	show_heroes.values = show_heroes.values.sort()
	show_heroes.Update()
})
let current_replacing = "",
	waiting_ability_selection = false
EventsSDK.on("GameEnded", () => {
	players.values = []
	show_heroes.values = []
	show_heroes.Update()
	showed_heroes.entries = []
	showed_heroes.Update()
	current_replacing = ""
	waiting_ability_selection = false
})
show_heroes.OnValue(selector => {
	enabled_ability_list.clear()
	showed_heroes.entries = []
	// loop-optimizer: KEEP
	selector.enabled_values.forEach((val, key) => {
		if (!val || !selector.values.includes(key))
			return
		let selector2 = showed_heroes.AddNode(key).AddImageSelector("Select abilities to roll", hero_ability_list[key.substring(14)])
		selector2.enabled_values.clear()
		selector2.Update()
		selector2.OnValue(() => {
			// loop-optimizer: KEEP
			selector2.enabled_values.forEach((val, key) => enabled_ability_list.set(key, val))
		})
	})
	showed_heroes.Update()
})

function GiveBookToSelf() {
	GameEvents.FireEventToServer("RelearnBookAbilitySelected", {
		player_id: LocalPlayer!.PlayerID,
	})
}

roll_ability.OnValue(() => {
	if (current_replacing !== "")
		return
	// loop-optimizer: KEEP
	ability_replace.enabled_values.forEach((val, key) => {
		if (val && current_replacing === "" && ability_replace.values.includes(key))
			current_replacing = key
	})
	if (current_replacing !== "")
		GiveBookToSelf()
})

let pair = { "1": 1, "2": 2 }
EventsSDK.on("CustomGameEvent", (name, obj) => {
	if (name === "ShowPvpBet")
		pair = obj.pair
	else if (name === "ShowRelearnBookAbilitySelection" && current_replacing !== "") {
		GameEvents.FireEventToServer("RelearnBookAbilitySelected", {
			player_id: LocalPlayer!.PlayerID,
			ability_name: current_replacing,
		})
		waiting_ability_selection = true
	} else if (name === "ShowRandomAbilitySelection" && waiting_ability_selection) {
		let abils = Object.values(obj.data_list).map(o => (o as any).ability_name) as string[]
		let abil = abils.find(abil => enabled_ability_list.get(abil) === true)
		GameEvents.FireEventToServer("AbilitySelected", {
			player_id: LocalPlayer!.PlayerID,
			ability_name: abil ?? abils[0],
			spell_book_selected: 0,
		})
		if (abil === undefined) {
			current_replacing = abils[0]
			GiveBookToSelf()
		} else
			current_replacing = ""
		waiting_ability_selection = false
	}
})

EventsSDK.on("Tick", () => {
	const hero = LocalPlayer!.Hero
	if (hero !== undefined) {
		ability_replace.values = hero.Spells.map(spell => spell?.Name).filter(name => name !== undefined && !unremovableAbilities.includes(name)) as string[]
		ability_replace.Update()
		/*hero.Spells.forEach(spell => {
			if (spell === undefined)
				return
			let forbid = abilityExclusion.get(spell.Name)
			if (forbid !== undefined)
				ArrayExtensions.arrayRemove(ability_roll.values, forbid)
		})
		heroExclusion.get(hero.Name)?.forEach(forbid => ArrayExtensions.arrayRemove(ability_roll.values, forbid))
		// loop-optimizer: KEEP
		abilityPersonal.forEach((hero_name, spell) => {
			if (hero_name !== hero.Name)
				ArrayExtensions.arrayRemove(ability_roll.values, spell)
		})
		ability_roll.Update()*/

		if (current_replacing !== "" && !waiting_ability_selection && hero.IsAlive) {
			let book = hero.GetItemByName("item_relearn_book_lua")
			if (book !== undefined)
				hero.CastNoTarget(book, false)
		}
	}
	players.values = ArrayExtensions.orderBy(
		EntityManager.GetEntitiesByClass(Player).filter(p => p.Hero !== undefined),
		p => p.PlayerID
	).map(a => a.Hero!.Name)
	players.Update()
	if (players.values.length === 0)
		return
	// loop-optimizer: KEEP
	players.enabled_values.forEach((val, hero_name) => {
		if (!val)
			return
		let hero = EntityManager.GetEntitiesByClass(Hero).find(hero => hero.Name === hero_name && hero.Owner instanceof Player && hero.Owner.Hero === hero)
		if (hero === undefined)
			return
		GameEvents.FireEventToServer("ConfirmBet", {
			player_id: (hero.Owner as Player).PlayerID,
			value: 100000,
			wish_player_id: pair[(Math.random() > 0.5) ? "1" : "2"],
		})
	})
})
